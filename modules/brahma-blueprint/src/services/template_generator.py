"""
ðŸ—ï¸ Template Generator Service
==============================

Generates infrastructure-as-code templates (Terraform, Ansible, ARM, etc.)
from architecture blueprints. Supports multiple cloud providers and
deployment methods.
"""

import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from .ai_engine import ArchitectureBlueprint, InfrastructureComponent

logger = logging.getLogger(__name__)


@dataclass
class TemplateOutput:
    """Generated template output"""
    terraform_code: str
    ansible_playbooks: Dict[str, str]
    arm_templates: Optional[Dict[str, str]] = None
    docker_compose: Optional[str] = None
    kubernetes_manifests: Optional[Dict[str, str]] = None


class TemplateGenerator:
    """
    Infrastructure-as-Code template generator
    
    Converts architecture blueprints into deployable templates
    for various platforms and tools.
    """
    
    def __init__(self):
        self.terraform_providers = self._initialize_terraform_providers()
        self.ansible_modules = self._initialize_ansible_modules()
    
    async def generate_terraform(
        self,
        architecture: ArchitectureBlueprint,
        cloud_provider: str = "azure",
        region: str = "eastus",
        tags: Optional[Dict[str, str]] = None
    ) -> str:
        """Generate Terraform configuration"""
        try:
            logger.info("Generating Terraform code for %s", cloud_provider)
            
            terraform_code = self._generate_terraform_header(
                cloud_provider, region
            )
            
            # Generate variable definitions
            terraform_code += self._generate_terraform_variables(
                architecture, tags or {}
            )
            
            # Generate resource definitions
            for component in architecture.components:
                terraform_code += self._generate_terraform_resource(
                    component, cloud_provider
                )
            
            # Generate outputs
            terraform_code += self._generate_terraform_outputs(architecture)
            
            logger.info("Terraform code generated successfully")
            return terraform_code
            
        except Exception as e:
            logger.error("Error generating Terraform code: %s", str(e))
            raise
    
    async def generate_ansible(
        self,
        architecture: ArchitectureBlueprint,
        environment: str = "development"
    ) -> Dict[str, str]:
        """Generate Ansible playbooks"""
        try:
            logger.info("Generating Ansible playbooks for %s", environment)
            
            playbooks = {}
            
            # Main deployment playbook
            playbooks["deploy.yml"] = self._generate_ansible_deploy_playbook(
                architecture, environment
            )
            
            # Configuration playbooks per component type
            component_types = set(
                comp.type for comp in architecture.components
            )
            
            for comp_type in component_types:
                components = [
                    c for c in architecture.components if c.type == comp_type
                ]
                playbooks[f"configure_{comp_type}.yml"] = (
                    self._generate_ansible_component_playbook(
                        comp_type, components
                    )
                )
            
            # Inventory file
            playbooks["inventory.ini"] = self._generate_ansible_inventory(
                architecture
            )
            
            logger.info("Ansible playbooks generated successfully")
            return playbooks
            
        except Exception as e:
            logger.error("Error generating Ansible playbooks: %s", str(e))
            raise
    
    def _generate_terraform_header(
        self, cloud_provider: str, region: str
    ) -> str:
        """Generate Terraform provider configuration"""
        if cloud_provider == "azure":
            return f'''# Generated by AetherEdge Brahma Blueprint Engine
terraform {{
  required_version = ">= 1.0"
  required_providers {{
    azurerm = {{
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }}
  }}
}}

provider "azurerm" {{
  features {{}}
}}

# Local values
locals {{
  location = "{region}"
  common_tags = merge(var.tags, {{
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "AetherEdge"
  }})
}}

'''
        elif cloud_provider == "aws":
            return f'''# Generated by AetherEdge Brahma Blueprint Engine
terraform {{
  required_version = ">= 1.0"
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}

provider "aws" {{
  region = "{region}"
}}

# Local values
locals {{
  region = "{region}"
  common_tags = merge(var.tags, {{
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "AetherEdge"
  }})
}}

'''
        else:
            return f"# Unsupported cloud provider: {cloud_provider}\n"
    
    def _generate_terraform_variables(
        self, architecture: ArchitectureBlueprint, tags: Dict[str, str]
    ) -> str:
        """Generate Terraform variable definitions"""
        variables = '''# Variables
variable "project_name" {
  description = "Name of the project"
  type        = string
  default     = "aetheredge-blueprint"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "development"
}

variable "tags" {
  description = "Common tags for all resources"
  type        = map(string)
  default     = {}
}

'''
        
        # Add component-specific variables
        for component in architecture.components:
            variables += f'''variable "{component.name}_enabled" {{
  description = "Enable {component.name} component"
  type        = bool
  default     = true
}}

'''
        
        return variables
    
    def _generate_terraform_resource(
        self, component: InfrastructureComponent, cloud_provider: str
    ) -> str:
        """Generate Terraform resource for a component"""
        if cloud_provider == "azure":
            return self._generate_azure_terraform_resource(component)
        elif cloud_provider == "aws":
            return self._generate_aws_terraform_resource(component)
        else:
            return f"# Unsupported provider for {component.name}\n"
    
    def _generate_azure_terraform_resource(
        self, component: InfrastructureComponent
    ) -> str:
        """Generate Azure Terraform resources"""
        resource_code = f"\n# {component.name} - {component.type}\n"
        
        if component.type == "web_app":
            resource_code += f'''resource "azurerm_service_plan" "{component.name}_plan" {{
  count               = var.{component.name}_enabled ? 1 : 0
  name                = "${{var.project_name}}-{component.name}-plan"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  os_type             = "Linux"
  sku_name            = "P1v2"
  tags                = local.common_tags
}}

resource "azurerm_linux_web_app" "{component.name}" {{
  count               = var.{component.name}_enabled ? 1 : 0
  name                = "${{var.project_name}}-{component.name}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  service_plan_id     = azurerm_service_plan.{component.name}_plan[0].id
  
  site_config {{
    always_on = true
  }}
  
  tags = local.common_tags
}}

'''
        elif component.type == "database":
            resource_code += f'''resource "azurerm_postgresql_server" "{component.name}" {{
  count               = var.{component.name}_enabled ? 1 : 0
  name                = "${{var.project_name}}-{component.name}"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  
  administrator_login          = "adminuser"
  administrator_login_password = random_password.{component.name}_password[0].result
  
  sku_name   = "B_Gen5_1"
  version    = "11"
  storage_mb = 5120
  
  backup_retention_days = 7
  ssl_enforcement_enabled = true
  
  tags = local.common_tags
}}

resource "random_password" "{component.name}_password" {{
  count   = var.{component.name}_enabled ? 1 : 0
  length  = 16
  special = true
}}

'''
        elif component.type == "storage":
            resource_code += f'''resource "azurerm_storage_account" "{component.name}" {{
  count               = var.{component.name}_enabled ? 1 : 0
  name                = replace("${{var.project_name}}{component.name}", "-", "")
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  
  account_tier             = "Standard"
  account_replication_type = "LRS"
  
  tags = local.common_tags
}}

'''
        
        return resource_code
    
    def _generate_aws_terraform_resource(
        self, component: InfrastructureComponent
    ) -> str:
        """Generate AWS Terraform resources"""
        resource_code = f"\n# {component.name} - {component.type}\n"
        
        if component.type == "web_app":
            resource_code += f'''resource "aws_elastic_beanstalk_application" "{component.name}_app" {{
  count = var.{component.name}_enabled ? 1 : 0
  name  = "${{var.project_name}}-{component.name}"
  
  tags = local.common_tags
}}

resource "aws_elastic_beanstalk_environment" "{component.name}" {{
  count               = var.{component.name}_enabled ? 1 : 0
  name                = "${{var.project_name}}-{component.name}-env"
  application         = aws_elastic_beanstalk_application.{component.name}_app[0].name
  solution_stack_name = "64bit Amazon Linux 2 v3.4.0 running Python 3.8"
  
  tags = local.common_tags
}}

'''
        elif component.type == "database":
            resource_code += f'''resource "aws_db_instance" "{component.name}" {{
  count = var.{component.name}_enabled ? 1 : 0
  
  identifier = "${{var.project_name}}-{component.name}"
  
  engine         = "postgres"
  engine_version = "13.7"
  instance_class = "db.t3.micro"
  
  allocated_storage     = 20
  max_allocated_storage = 100
  
  db_name  = replace(var.project_name, "-", "")
  username = "adminuser"
  password = random_password.{component.name}_password[0].result
  
  skip_final_snapshot = true
  
  tags = local.common_tags
}}

resource "random_password" "{component.name}_password" {{
  count   = var.{component.name}_enabled ? 1 : 0
  length  = 16
  special = true
}}

'''
        
        return resource_code
    
    def _generate_terraform_outputs(
        self, architecture: ArchitectureBlueprint
    ) -> str:
        """Generate Terraform outputs"""
        outputs = "\n# Outputs\n"
        
        for component in architecture.components:
            if component.type == "web_app":
                outputs += f'''output "{component.name}_url" {{
  description = "URL for {component.name}"
  value       = var.{component.name}_enabled ? "https://${{azurerm_linux_web_app.{component.name}[0].default_hostname}}" : null
}}

'''
            elif component.type == "database":
                outputs += f'''output "{component.name}_fqdn" {{
  description = "FQDN for {component.name}"
  value       = var.{component.name}_enabled ? azurerm_postgresql_server.{component.name}[0].fqdn : null
  sensitive   = true
}}

'''
        
        return outputs
    
    def _generate_ansible_deploy_playbook(
        self, architecture: ArchitectureBlueprint, environment: str
    ) -> str:
        """Generate main Ansible deployment playbook"""
        playbook = f'''---
# Generated by AetherEdge Brahma Blueprint Engine
# Main deployment playbook for {architecture.pattern.value}

- name: Deploy {architecture.pattern.value} infrastructure
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    environment: {environment}
    project_name: aetheredge-blueprint
    
  tasks:
    - name: Display deployment information
      debug:
        msg: "Deploying {{{{ project_name }}}} in {{{{ environment }}}} environment"
    
'''
        
        # Add tasks for each component
        for component in architecture.components:
            playbook += f'''    - name: Deploy {component.name}
      include_tasks: configure_{component.type}.yml
      vars:
        component_name: {component.name}
        component_properties: {component.properties}
    
'''
        
        return playbook
    
    def _generate_ansible_component_playbook(
        self, component_type: str, components: List[InfrastructureComponent]
    ) -> str:
        """Generate Ansible playbook for specific component type"""
        playbook = f'''---
# Configuration playbook for {component_type} components

- name: Configure {component_type}
  debug:
    msg: "Configuring {{{{ component_name }}}} of type {component_type}"

'''
        
        if component_type == "web_app":
            playbook += '''- name: Install application dependencies
  package:
    name: "{{ item }}"
    state: present
  loop:
    - python3
    - python3-pip
    - nginx

- name: Configure nginx
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
  notify: restart nginx

'''
        elif component_type == "database":
            playbook += '''- name: Install database
  package:
    name: postgresql
    state: present

- name: Configure database
  postgresql_db:
    name: "{{ component_name }}"
    state: present

'''
        
        return playbook
    
    def _generate_ansible_inventory(
        self, architecture: ArchitectureBlueprint
    ) -> str:
        """Generate Ansible inventory file"""
        inventory = '''# Generated inventory file
[all:vars]
ansible_connection=local

[localhost]
127.0.0.1

'''
        
        # Group hosts by component type
        component_types = {
            comp.type for comp in architecture.components
        }
        
        for comp_type in component_types:
            inventory += f"[{comp_type}]\n"
            components = [
                c for c in architecture.components if c.type == comp_type
            ]
            for component in components:
                inventory += f"{component.name} ansible_host=localhost\n"
            inventory += "\n"
        
        return inventory
    
    def _initialize_terraform_providers(self) -> Dict[str, Any]:
        """Initialize Terraform provider configurations"""
        return {
            "azure": {
                "provider": "azurerm",
                "version": "~> 3.0",
                "features": {}
            },
            "aws": {
                "provider": "aws",
                "version": "~> 5.0"
            },
            "gcp": {
                "provider": "google",
                "version": "~> 4.0"
            }
        }
    
    def _initialize_ansible_modules(self) -> Dict[str, List[str]]:
        """Initialize Ansible module mappings"""
        return {
            "web_app": ["package", "service", "template", "file"],
            "database": ["postgresql_db", "postgresql_user", "mysql_db"],
            "storage": ["file", "blockinfile", "mount"],
            "networking": ["iptables", "firewalld", "ufw"]
        }
